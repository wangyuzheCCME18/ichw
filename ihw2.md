# 概论作业2 (Sep/25/2018)

## 1、用你的语言描述图灵为什么要证明停机问题, 其证明方法和数学原理是什么

图灵在1936年提出通用计算机模型——图灵机后，面临着这样的问题：是否存在一个程序或者算法，能够判断任意程序在给定输入上最终能否结束？这便是著名的“停机问题”。如果“停机问题”有解，那么理论上就可以找到一个“万能程序”来判断任意一个程序能否无限运行下去；而利用这个万能程序，很多悬而未决的数学猜想就可以得到证明。例如，对于哥德巴赫猜想，我们可以编写一个从小到大枚举所有的偶数、看是不是有两个质数加起来等于它的程序，然后用上述“万能程序”判断这个程序会否停机；如果会停机，则哥德巴赫猜想证伪；否则，哥德巴赫猜想证实。对于前一段时间阿提亚爵士试图证明的黎曼猜想，我们同样可以用类似的方法解决。因此，研究停机问题对于很多数学命题是否有平凡解法的探索有着重大意义，如果上述“万能程序”理论上真的存在，人类历史上很多重大数学问题的解决就只是时间问题。同时，停机问题也是对希尔伯特“一个公理系统是否完备”问题的另一种层次的回答，如果存在这样的“万能程序”，公理系统内一切数学命题原则上都可由此经有限步推定真伪。因此，停机问题的证明对图灵而言是必要的。

图灵利用反证法证明了停机问题，其证明的核心是构造程序，利用“自指”的方法得出悖论。假设存在一个算法f可以判断任意程序在给定输入上能否停机，停机则输出true，不停机则输出false。那么可以构造一个程序g，使它的输出恰与f相反，f输出true则g输出false并无限循环，f输出false则g输出true并终止程序。现在，调用g（g）程序，结果就出现了悖论：若g不停机，f输出false，g停机；若g停机，f输出true，g不停机。因此不存在这样的算法f，停机问题证毕。

停机问题的证明背后蕴含着深刻的数学原理，这需要追溯到康托尔的对角线方法、希尔伯特的公理化体系和哥德尔不完备定理。20世纪初期，希尔伯特等人借助于形式化的手段，抽掉数学证明中的意义，把数学证明抽象成一堆无意义的符号转换，这样一来，一个我们日常所谓的带有直观意义和解释的数学系统就变成了一个纯粹由无意义符号表达的、公理加上推导规则所构成的形式系统。希尔伯特希望能够证明，在任一个无矛盾的形式系统中所能表达的所有陈述都要么能够证明，要么能够证伪。 然而，1931年，哥德尔在论文中证明，任意一个包含一阶谓词逻辑与初等数论的形式系统，都存在一个命题，它在这个系统中既不能被证明为真，也不能被证明为假，也即著名的哥德尔不完备定理。而哥德尔的证明方法，便是通过康托尔的对角线方法枚举形式系统中的所有命题，然后在该形式系统中构造一个新的自指的命题，即“这个命题不可在该形式系统中得到证明”，从而导出悖论。这一证明过程与图灵证明停机问题的过程十分相似，实际上，停机问题实际上也是哥德尔不完备定理的另一种表述，研究的也是是否一个形式系统中所有命题均可证实或证伪的问题。停机问题的证明，正是来自于哥德尔对于不完备定理的证明，根本地，来自于康托尔的对角线方法。也即，停机问题可以利用康托尔的对角线方法得到更严格地证明。这便是停机问题背后的数学原理。


## 2.	你在向中学生做科普，请向他们解释二进制补码的原理.

我们知道，二进制是用0和1表示的“逢二进一”的数；在计算机里，由于电路只有通断两种状态，数据都是以二进制形式存储的。那么大家有没有想过，负数在计算机中是如何表示和存储的呢？如何才能方便地实现正数和负数之间的加减呢？这些问题，都涉及到了现行计算机中用二进制补码表示整数的原理。

在二进制补码中，我们用最左边一位表示正负号，0代表正号，1代表负号，这一位称为符号位。符号位后面的数位表示这个整数的大小，可以理解成绝对值。正数的补码就采用正常方法用二进制表示，位数不够的话就在左端补“0”，写在符号位“0”之后；而对于负数，先求这个数相反数的二进制表示，位数不够的话就在左端补“0”，然后对每一位取反，也就是把“0”变成“1”，把“1”变成“0”，再把得到的数加1，把得到的结果写在符号位“1”之后。

在计算机进行运算的时候，两个数相加减，只需要进行包括符号位在内的补码相加，就可以得到正确的结果。这样，我们就把减法转化成了加法，大大方便了计算机进行计算。因为补码系统中只有一个“0”，因此在计算时不需要进行复杂的修正运算。补码本质上是一种数论中“同余取模”的思想，一个负数和其补码同余于2N（N是码长），在运算时相互等价，便实现了加减法的之间的转化。

以上，这就是二进制补码的原理。


## 3.	某基于 IEEE 754浮点数格式的 16 bit 浮点数表示, 有 8 个小数位, 请给出 ±0, ±1.0, 最大非规范化数, 最小非规范化数, 最小规范化浮点数, 最大规范化浮点数,±∞, NaN 的二进制表示(表示形式请参照讲义). 

+0：0 0000000 00000000

-0：1 0000000 00000000

+1.0：0 0111111 00000000

-1.0：1 0111111 00000000

最大非规范数：0 0000000 11111111

             1 0000000 11111111
             
最小非规范数：0 0000000 00000001

             1 0000000 00000001
             
最小规范化浮点数：0 0000001 00000000

                 1 0000001 00000000
                 
最大规范化浮点数：0 1111110 11111111

                 1 1111110 11111111
                 
+∞：0 1111111 00000000

-∞：1 1111111 00000000

NaN：0 1111111 （non zero  8位不全为0）

     1 1111111 （non zero  8位不全为0）

